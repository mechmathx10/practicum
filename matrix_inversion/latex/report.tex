\documentclass[12pt, russian]{article}

\usepackage[russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{dsfont}
\usepackage[a4paper,left=15mm,right=15mm, top=10mm,bottom=20mm,bindingoffset=0cm]{geometry}
\usepackage{natbib}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}

\title{Нахождение обратной матрицы блочным методом Жордана-Гаусса с выбором главного элемента по строке}
\author{Тырин Владимир, группа 310}
\date{}

\begin{document}

\maketitle

\section{Постановка задачи}
Дана вещественная квадратная матрица $A$. Найти обратную матрица $A^{-1}$ методом Жордана-Гаусса с выбором главного элемента по строке.

\section{Описание стандартного метода}

Опишем стандартный (не блочный) метод Жордана-Гаусса с выбором главного элемента по строке.
Пусть $A$ --- квадратная матрица порядка $n$. Припишем к ней справа единичную матрицу. Получим в результате матрицу порядка $n\times 2n$ обозначим через $(A_0|B_0) = (A|E)$, а впоследствии получающиеся из нее после матрицы через $(A_i|B_i)$. Элементы матриц в дальнейшем обозначаются через $a_{ikl}$, где $i$ --- номер шага алгоритма, $k$ --- номер строки, $l$ --- номер столбца.
\[
(A_0|B_0) = \left(
\begin{array} {rrrrr|rrrrr}
a_{11} & a_{12} & \ldots & a_{1,n-1} & a_{1n} & 1 & 0 & \ldots & 0 & 0 \\
a_{21} & a_{22} & \ldots & a_{2,n-1} & a_{2n} & 0 & 1 & \ldots & 0 & 0 \\
\ldots & \ldots & \ldots & \ldots & \ldots & \ldots & \ldots & \ldots & \ldots & \ldots \\
a_{n-1,1} & a_{n-1,2} & \ldots & a_{n-1,n-1} & a_{n-1,n} & 0 & 0 & \ldots & 1 & 0 \\
a_{n1} & a_{n2} & \ldots & a_{n,n-1} & a_{nn} & 0 & 0 & \ldots & 0 & 1 \\
\end{array}
\right)
\]

В алгоритме также будут использоваться перестановки столбцов матрицы. Для того, чтобы из результата преобразований корректно получить обратную матрицу, эти перестановки нужно запоминать. Начальная перестановка --- тождественная.
$$ \sigma_0 = \textbf{id} \in S_n $$
Все преобразования, описанные далее, выполняются одновременно для матриц $A_i$ и $B_i$. (перестановки столбцов, элементарные преобразования строк).
Алгоритм содержит $n$ шагов, $i$-ый из которых ($i=1..n$) устроен следующим образом:
\begin{enumerate}

\item Если $i$-ая строка --- нулевая, алгоритм завершается: матрица не имеет обратной. В противном случае выберем в $i$-ой строке максимальный по модулю элемент. Обозначим номер содержащего его столбца через $j_i$. Переставим в матрицах $A_{i-1}$ и $B_{i-1}$ столбцы с номерами $i$ и $j_i$, после чего разделим $i$-ые строки полученных матриц на $a_{i-1,i,j_i}$. Результат обозначим через $(\tilde{A_i}|\tilde{B_i})$.

\item Домножим перестановку $\sigma_{i-1}$ слева на транспозицию $(i,j_i)$:
$$ \sigma_i = (i,j_i) \cdot \sigma_{i,j_i} $$

\item Вычтем из всех последующих строк (номер уменьшаемой строки обозначим через $k,\,k\in i+1..n$) $i$-ую строку, домноженную на $\tilde{a}_{i-1,li}$. Результат выполнения операции обозначим через $(A_i|B_i)$. Выполнены соотношения для элементов:
\pagebreak
$$ a_{ikl} = \tilde{a}_{i-1,kl},\quad k=1..i $$
$$ b_{ikl} = \tilde{b}_{i-1,kl},\quad k=1..i $$
$$ a_{ikl} = \tilde{a}_{i-1,kl} - \tilde{a}_{i-1,il}\tilde{a}_{i-1,ki},\quad l=i+1..n $$
$$ b_{ikl} = \tilde{b}_{i-1,kl} - \tilde{b}_{i-1,il}\tilde{b}_{i-1,ki},\quad l=i+1..n $$

\end{enumerate}

После выполнения шага $i.3$ ($x.y$ --- $y$-ый этап $x$-го шага алгоритма), очевидно, столбцы матрицы $A_i$ с номерами $1..i$ совпадают с соответствующими столбцами единичной матрицы порядка $n$. Соответственно, $$A_n = E$$. Матрица $B_n$ является обратной к $A$ с точностью до перестановки строк (фактически, перенумерования неизвестных в системе уравнений $AX=E$). Обозначим через $\tilde{B}_n$ матрицу, полученную из $B_n$ перестановкой строк с помощью $\sigma_n$. Тогда
$$ \tilde{B}_n = A^{-1} $$
Метод применим тогда и только тогда, когда $A$ --- невырожденная матрица.

\section{Блочный вариант метода}

Блочный является модификацией обычного с тем различием, что вместо отдельных элементов в нем используются подматрицы (блоки) исходной матрицы. Опишем подробнее.

\subsection{Разбиение на блоки}

Фиксируем размер блока $m$, $1\leq m \leq n$. Разделим $n$ на $m$ с остатком
$$ n = qm + r,\quad q\in \mathbb{Z}_+,\quad 0\leq r\leq m-1 $$
Интерес представляет случай $q > 0$. Разобьем матрицу $A$ на блоки размеров $m\times m$, начиная с левого верхнего угла. Оставшиеся справа и снизу элементы попадут в блоки меньшего размера. Справа к матрице $A$, как и в исходном методе, припишем единичную матрицу, для нее проведем такое же разбиение (заметим, что все блоки матрицы $E$ --- либо единичные матрицы, либо нулевые). Получим следующий вид ($0^{x\times y}$ обозначает нулевую матрицу порядка $x \times y$):

\[
(A|B) = \left(
\begin{array} {rrrrr|rrrrr}
A_{11}^{m\times m} & A_{12}^{m\times m} & \ldots & A_{1q}^{m\times m} & A_{1,q+1}^{m\times r}
& E^{m\times m} & 0^{m\times m} & \ldots & 0^{m\times m} & 0^{m\times r} \\
A_{21}^{m\times m} & A_{22}^{m\times m} & \ldots & A_{2q}^{m\times m} & A_{2,q+1}^{m\times r}
& 0^{m\times m} & E^{m\times m} & \ldots & 0^{m\times m} & 0^{m\times r} \\
\ldots & \ldots & \ldots & \ldots & \ldots & \ldots & \ldots & \ldots & \ldots & \ldots \\
A_{q1}^{m\times m} & A_{q2}^{m\times m} & \ldots & A_{qq}^{m\times m} & A_{q,q+1}^{m\times r}
& 0^{m\times m} & 0^{m\times m} & \ldots & E^{m\times m} & 0^{m\times r} \\
A_{q+1,1}^{r\times m} & A_{q+1,2}^{r\times m} & \ldots & A_{q+1,q}^{r\times m} & A_{q,q+1}^{r\times r}
& 0^{r\times m} & 0^{r\times m} & \ldots & 0^{r\times m} & E^{r\times r} \\
\end{array}
\right)
\]

\subsection{Обозначения}

Для обозначения шага алгоритма, в результате которого был получен блок или матрица, будем использовать левые нижние индексы. Таким образом, запись ${}_x A_{yz}^{\alpha\times\beta}$ --- блок матрицы $A$, полученный в результате шага номер $x$, находящийся на пересечении строки $y$ и столбца $z$ (имеются ввиду строки и столбцы блоков) и имеющий $\alpha$ строк и $\beta$ столбцов. В частности
$$ ({}_0 A|{}_0 B) = (A|E) $$
Промежуточные результаты обозначаются теми же буквами с волной (и с теми же индексами)

\pagebreak
\subsection{Ход алгоритма}

\end{document}